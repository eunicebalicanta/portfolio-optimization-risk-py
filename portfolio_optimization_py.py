# -*- coding: utf-8 -*-
"""portfolio_optimization_py.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1llCcHWnC-B7Y9f1heF1LMejNuDm-qmhk

# Portfolio Optimization and Asset Allocation Visualization

###Objective
This project provides a hands-on approach to optimizing a portfolio of stocks, exchange-traded funds (ETFs), and foreign exchange (FX) spot rates, based on various financial metrics. The aim is to help investors and analysts maximize returns while managing risks effectively, using different optimization strategies. The user inputs tickers (up to 50), and the project pulls relevant financial data to generate actionable insights, including visualizations of asset allocations and portfolio performance. This process is further enhanced by historical backtesting and correlation analysis.

###Data Collection
The historical price data of the selected tickers is collected from Yahoo! Finance for a specified four-year time frame, from 2020-01-01 to 2024-01-01. This data includes daily stock prices, ETFs, and FX spot rates, which are then processed to compute daily returns. The code supports multiple types of tickers, including:

- Stocks (e.g., AAPL, AMZN)
- ETFs (e.g., VOO, SPY)
- FX Spot Rates (e.g., JPY=X for Japanese Yen)

###Financial Models
The project utilizes several optimization techniques, including:

- Sharpe Ratio: Maximizes return per unit of risk by considering the excess return

- Kelly Criterion: Determines the optimal proportion of the portfolio to invest in each asset, aiming to maximize the expected logarithm of wealth

- Conditional Value at Risk (CVaR): Minimizes potential losses in adverse scenarios, enhancing overall risk management

- Risk Parity: Balances risk across the portfolio to ensure equal contributions to total risk from each asset

###Backtesting Performance
To assess the effectiveness of these models, the portfolio is backtested using an initial budget of $100,000. The backtesting process evaluates how each optimized portfolio would have performed over time. This includes:

- Plotting Cumulative Returns: The value of the portfolio is tracked from the start to the end of the test period

- Comparison of Models: The portfolio's growth under different optimization strategies (Sharpe Ratio, Kelly, CVaR, Risk Parity) is visualized to identify which model yields the best results

###Efficient Frontier Visualization
The Efficient Frontier represents the set of optimal portfolios offering the highest expected return for a defined level of risk. The visualization uses the mean-variance optimization framework and includes:

- Volatility vs. Return: Portfolios are plotted on a scatter plot with expected return on the y-axis and portfolio volatility (standard deviation) on the x-axis

- Sharpe Ratio Visualization: The efficient frontier is color-coded to highlight portfolios based on their Sharpe Ratios. Higher Sharpe Ratios are shown in brighter colors

- Optimal Portfolio Markers: A star marks the most optimal portfolio based on the highest Sharpe Ratio.
An 'X' indicates other portfolios with lower risk at various volatility levels

###Correlation Heatmap:
In addition to portfolio optimization, the code generates a heatmap based on the correlation matrix of the returns. This helps investors understand how the selected assets move in relation to one another. The correlation matrix reveals the degree to which asset prices are correlated:

- Correlation Coefficients: Values close to 1 indicate a strong positive correlation, while values close to -1 indicate a strong negative correlation. A value of 0 implies no correlation

- Interpretation: Highly correlated assets tend to move together, while uncorrelated or negatively correlated assets provide diversification benefits. The heatmap visually represents these relationships, aiding in diversification strategy

#### Asset Allocation by Industry:
To provide a broader understanding of the portfolio's composition, the code generates a pie chart showing asset allocation by industry. This feature utilizes Yahoo! Finance's industry classifications to break down the investments by sectors
"""

# Install libraries
!pip install pandas
!pip install numpy
!pip install matplotlib
!pip install yfinance
!pip install seaborn
!pip install scipy

print("All libraries installed")

# Import libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as mticker
import yfinance as yf
import requests
import seaborn as sns
import scipy.optimize as sco

print("All libraries imported")

# Retrieve Yahoo! Finance ticker information
def get_asset_data(tickers, start_date, end_date):
    asset_data = yf.download(tickers, start=start_date, end=end_date)['Adj Close']
    return asset_data

def get_company_names(tickers):
    names = {}
    for ticker in tickers:
        try:
            name = yf.Ticker(ticker).info['longName']
            names[ticker] = name
        except KeyError:
            names[ticker] = "N/A"
    return names

"""#### Mean-Variance Portfolio:
The Mean-Variance Portfolio theory,  focuses on the trade-off between risk and return in investment decisions. This approach aims to construct an optimal portfolio by considering the expected returns (mean) and the associated risks (variance) of the assets. The key concept is the Efficient Frontier, which represents a set of optimal portfolios that offer the highest expected return for a given level of risk. Investors can select portfolios along this frontier based on their risk tolerance.

#### Maximum Sharpe Ratio Portfolio:
This is a specific application of the mean-variance optimization framework. It seeks to maximize the Sharpe Ratio, which measures the risk-adjusted return of a portfolio. The Sharpe Ratio is calculated as the difference between the portfolio return and the risk-free rate, divided by the portfolio's standard deviation.

![Screenshot 2024-10-23 at 11.01.07 PM.png](data:image/png;base64,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BAyB9kPg1Vdf5RA2/1l11VVTH+C+++4LZT799NNEmaOOOirki+BI5BcnbLLJJqH8o48+WpA9evToqGvXrj5/0kknjWQQLciv9Z8111zT85YVR62sGlq/IzFq6IPFmLvYvd0aAoZAGyEwbNiwMIj36dMnteeiWvJlZKM7NT+v4FhsscU8P1FPRbJ5neApK6DQp6uuuiqRX0tCuwiOjsSoFnzz1DXBkQctK2sItBAC/fv3D4P07bffntqz//77L+rbt2909dVXp+bnERyi+oomm2wy3yaDYxqdc845oU+yn5JWpOq0dhAcHY1R1eDmrGiCIydgVtwQaBUEZL8hDNJpaqgs/cwjOEaMGBHa22uvvVLZb7311qHM0KFDU8tUm9gOgqOjMaoW27z1THDkRczKGwItgMC///4bTTvttH6QFp+Ggh79+eef0ZFHHhldeOGFBelp/+QRHOeee24QCmLVlWBHn8SyypeZaKKJog8//DBRppaEdhAcHY1RLfjmqWuCIw9aVtYQaBEE3n777TCIM8uPE6opNs333nvveHLqfR7Bse2224Y2aT9O//zzT7TzzjuH/P322y+eXZf7dhAcHY1RXYDOwMQERwaQrIgh0GoIsPGsFlULLLBAtMcee0S77rpr1K1bt5B+3XXXVex2HsEx55xzet6sdFhdKL333nvRVlttFdpdY401IvFI1+y6XdtBcHQ0RnUDuwIjExwVALJsQ6AVEWCPQQXHTDPNFM0yyywRV1REmp5FVZRVcIgjXuAL/+7du0eYxapqirR55503Ek/vCFVZI6jVBUcrYNQI3NN4mgOgvPFGhkC7IbDEEku4d955x00yySSOeFN4ekPvv/++W3TRRd2ss84aHP/KPVtWB8A77rjDbbfddp7Vkksu6eabbz7PX3xJfNoiiyziRo4c6cTqqlxzNeVV4wAoqy7366+/Zmp3qqmm8l7vmQqnFGoFjFK61ZikNGliaYaAIdC6COA/gR+FjAjRsssum+ioCJFo++23T6SnJWRdcbDZTnt8JDRJYNVI89vQyP9vqllxTD/99KHf2v9SV8rWQvXE6O+///Ym1Ouvv75f2c0///zRSSedVEv36lrXVhzyFhkZAu2EwOOPP+5kQPFdJn5TWiDArM+TdcUhnunuhRde8HGpiKYrg6xvgrAmM844o+Mq+yuOkBuNompWHDvttJNf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)
"""

# Define functions for Maximum Sharpe Ratio
def calculate_daily_returns(asset_data):
    return asset_data.pct_change().dropna()

def portfolio_performance(weights, returns):
    portfolio_return = np.dot(weights, returns.mean()) * 252
    portfolio_std_dev = np.sqrt(np.dot(weights.T, np.dot(returns.cov() * 252, weights)))
    return portfolio_return, portfolio_std_dev

def negative_sharpe_ratio(weights, returns, risk_free_rate=0.01):
    portfolio_return, portfolio_std_dev = portfolio_performance(weights, returns)
    return -(portfolio_return - risk_free_rate) / portfolio_std_dev

def optimize_portfolio_sharpe(returns):
    num_assets = len(returns.columns)
    best_sharpe = -np.inf
    best_weights = None
    for _ in range(10000):
        weights = np.random.random(num_assets)
        weights /= np.sum(weights)
        sharpe = -negative_sharpe_ratio(weights, returns)
        if sharpe > best_sharpe:
            best_sharpe = sharpe
            best_weights = weights
    return best_weights

"""
#### Risk Parity:

This investment strategy aims to allocate risk evenly across all assets in a portfolio rather than allocating capital equally. The underlying principle is that each asset should contribute equally to the total risk of the portfolio, leading to better diversification and improved risk-adjusted returns."""

# Define functions for Risk Parity
def risk_contribution(weights, cov_matrix):
    portfolio_volatility = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))
    marginal_contributions = np.dot(cov_matrix, weights) / portfolio_volatility
    risk_contributions = weights * marginal_contributions
    return risk_contributions

def risk_parity_objective(weights, cov_matrix):
    risk_contributions = risk_contribution(weights, cov_matrix)
    return np.sum((risk_contributions - np.mean(risk_contributions))**2)

def optimize_portfolio_risk_parity(returns):
    cov_matrix = returns.cov() * 252
    num_assets = len(returns.columns)
    constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})
    bounds = tuple((0, 1) for _ in range(num_assets))
    initial_guess = np.array(num_assets * [1. / num_assets])
    result = sco.minimize(risk_parity_objective, initial_guess, args=(cov_matrix,), method='SLSQP', bounds=bounds, constraints=constraints)
    return result.x if result.success else initial_guess

"""#### Conditional Value at Risk (CVaR)

Also known as Expected Shortfall, CVaR is a risk assessment measure and strategy that focuses on calculating tail loss. By focusing on the worst p% of cases, where p is the confience level (95-99%), this provides asset allocation that can better mitigate extreme drawdowns and volatility.
"""

# Define functions for Conditional Value at Risk (CVaR)
def optimize_portfolio_cvar(returns, alpha=0.05):
    def cvar_objective(weights):
        portfolio_returns = returns.dot(weights)
        var = np.percentile(portfolio_returns, 100 * (1 - alpha))
        cvar = portfolio_returns[portfolio_returns <= var].mean()
        return -cvar
    constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})
    bounds = tuple((0, 1) for _ in range(len(returns.columns)))
    initial_guess = np.array(len(returns.columns) * [1. / len(returns.columns)])
    result = sco.minimize(cvar_objective, initial_guess, method='SLSQP', bounds=bounds, constraints=constraints)
    return result.x if result.success else initial_guess

"""#### Kelly Criterion:

The Kelly Criterion is a mathematical formula designed to determine the optimal size of a bet or investment allocation that maximizes the expected logarithm of wealth over the long term. By balancing risk and reward, it aims to maximize capital growth. Unlike Risk Parity and Conditional Value at Risk, the criterion focuses on the relationship between expected returns and the probabilities of winning and losing, emphasizing the optimal growth rate of capital rather than specifically managing losses.

Capital (or risk) per investment is simplified as "C" in the formula below:

![Screenshot 2024-10-23 at 11.24.47 PM.png](data:image/png;base64,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)
"""

# Calculate Kelly Criterion
def optimize_portfolio_kelly(returns):
    mean_returns = returns.mean() * 252
    cov_matrix = returns.cov() * 252
    inv_cov_matrix = np.linalg.inv(cov_matrix)
    weights = np.dot(inv_cov_matrix, mean_returns) / np.dot(mean_returns.T, np.dot(inv_cov_matrix, mean_returns))
    weights = np.maximum(weights, 0)
    return weights / np.sum(weights)

# Plot Efficient Frontier and Portfolio Asset Allocations
def plot_portfolio_weights(weights, tickers, model):
    plt.figure(figsize=(8, 8))
    plt.pie(weights, labels=tickers, autopct='%1.1f%%', startangle=140)
    plt.title(f'{model} Optimal Weights')
    plt.axis('equal')
    plt.show()

def get_company_industry(tickers):
    industries = {}
    for ticker in tickers:
        try:
            stock = yf.Ticker(ticker)
            info = stock.info
            industries[ticker] = info.get('industry', 'Unknown')
        except Exception as e:
            print(f"Error fetching data for {ticker}: {e}")
            industries[ticker] = 'Error'
    return industries

def plot_asset_allocation(industries):
    industry_counts = {}
    for industry in industries.values():
        if industry in industry_counts:
            industry_counts[industry] += 1
        else:
            industry_counts[industry] = 1
    labels = industry_counts.keys()
    sizes = industry_counts.values()
    plt.figure(figsize=(10, 7))
    plt.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=140)
    plt.axis('equal')
    plt.title('Asset Allocation by Industry')
    plt.show()

# Perform backtesting for each optimal portfolio
def backtest_portfolio(weights, returns, initial_investment=100000):
    portfolio_returns = (returns @ weights).dropna()
    cumulative_returns = (1 + portfolio_returns).cumprod() - 1
    portfolio_value = initial_investment * (1 + cumulative_returns)
    return portfolio_value
def currency_formatter(x, pos):
    return f'${x:,.0f}'

# Plot Efficient Frontier and Backtesting Time Series Analysis
def plot_efficient_frontier(returns, weights_mean_variance, num_portfolios=10000):
    results = np.zeros((3, num_portfolios))
    weights_list = []
    for i in range(num_portfolios):
        weights = np.random.random(len(returns.columns))
        weights /= np.sum(weights)
        portfolio_return, portfolio_std_dev = portfolio_performance(weights, returns)
        results[0, i] = portfolio_return
        results[1, i] = portfolio_std_dev
        results[2, i] = (portfolio_return - 0.01) / portfolio_std_dev
        weights_list.append(weights)
    mv_return, mv_std_dev = portfolio_performance(weights_mean_variance, returns)
    plt.figure(figsize=(12, 8))
    scatter = plt.scatter(results[1, :], results[0, :], c=results[2, :], cmap='viridis', marker='o', alpha=0.7)
    plt.colorbar(scatter, label='Sharpe Ratio')
    plt.scatter(mv_std_dev, mv_return, color='red', marker='*', s=200, label='Mean-Variance Optimal Portfolio')
    plt.scatter(results[1, results[2].argsort()[-5:]], results[0, results[2].argsort()[-5:]], color='blue', marker='x', label='Other Optimal Portfolios')
    plt.xlabel('Volatility (Standard Deviation)')
    plt.ylabel('Expected Annual Return')
    plt.title('Efficient Frontier with Optimal Portfolios (Sharpe Ratio)')
    plt.grid()
    plt.legend()
    plt.show()

def plot_correlation_heatmap(returns):
    correlation_matrix = returns.corr()
    plt.figure(figsize=(10, 8))
    sns.heatmap(correlation_matrix, annot=True, cmap='viridis', fmt=".2f", linewidths=0.5)
    plt.title("Correlation Heatmap of Asset Returns")
    plt.show()

def main():
    tickers = []
    print("Enter up to 50 stock, ETF, or FX spot rate tickers as listed on Yahoo! Finance (for ex. AAPL, VFV.TO, JPY=X)")
    print("Type 'stop' to finish.")
    while len(tickers) < 50:
        print(f"Current tickers: {', '.join(tickers) if tickers else 'None'}")
        user_input = input("Ticker: ").strip().upper()
        if user_input.lower() == 'stop':
            break
        if user_input and user_input not in tickers:
            tickers.append(user_input)
        else:
            print("Invalid input. Please enter a new ticker symbol or type 'stop' to finish.")

    start_date = '2020-01-01'
    end_date = '2024-01-01'
    asset_data = get_asset_data(tickers, start_date, end_date)
    returns = calculate_daily_returns(asset_data)
    company_names = get_company_names(tickers)

    print("Optimizing portfolio using Mean-Variance...")
    weights_sharpe = optimize_portfolio_sharpe(returns)
    plot_portfolio_weights(weights_sharpe, tickers, 'Sharpe Ratio')
    cumulative_value_sharpe = backtest_portfolio(weights_sharpe, returns)

    print("Optimizing portfolio using Risk Parity...")
    weights_risk_parity = optimize_portfolio_risk_parity(returns)
    plot_portfolio_weights(weights_risk_parity, tickers, 'Risk Parity')
    cumulative_value_risk_parity = backtest_portfolio(weights_risk_parity, returns)

    print("Optimizing portfolio using Conditional Value at Risk...")
    weights_cvar = optimize_portfolio_cvar(returns)
    plot_portfolio_weights(weights_cvar, tickers, 'Conditional Value at Risk')
    cumulative_value_cvar = backtest_portfolio(weights_cvar, returns)

    print("Optimizing portfolio using Kelly Criterion...")
    weights_kelly = optimize_portfolio_kelly(returns)
    plot_portfolio_weights(weights_kelly, tickers, 'Kelly Criterion')
    cumulative_value_kelly = backtest_portfolio(weights_kelly, returns)

    plt.figure(figsize=(14, 8))
    plt.plot(cumulative_value_sharpe, label='Sharpe Ratio Portfolio', color='blue')
    plt.plot(cumulative_value_risk_parity, label='Risk Parity Portfolio', color='orange')
    plt.plot(cumulative_value_cvar, label='CVaR Portfolio', color='green')
    plt.plot(cumulative_value_kelly, label='Kelly Criterion Portfolio', color='red')
    plt.title('Portfolio Value Over Time with $100,000 Initial Investment')
    plt.xlabel('Date')
    plt.ylabel('Portfolio Value ($)')
    plt.gca().yaxis.set_major_formatter(mticker.FuncFormatter(currency_formatter))
    plt.legend()
    plt.grid()
    plt.show()

    industries = get_company_industry(tickers)
    plot_asset_allocation(industries)

    print("Plotting Efficient Frontier...")
    plot_efficient_frontier(returns, weights_sharpe)

    print("Plotting Correlation Heatmap...")
    plot_correlation_heatmap(returns)

if __name__ == "__main__":
    main()

